// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppGSL)]]
#include <RcppGSL.h>
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
#ifdef _OPENMP
#include <omp.h>
#endif
// [[Rcpp::plugins(openmp)]]
#include "class_mixed_warped_curve2.h"
#include "class_mixed_warped_model2.h"

//' Internal function for fitting the model by SAEM
//'
//' @param curve_list List of curve objects, each should have a component called data, with subcomponents, x and y,
//'        for the time and value of the functional data
//' @param pars_list List with components: mu, kappa and sigma2
//' @param control_list List generated by control_saem()
//' @param y_scaling_factor Numeric value for scaling back the estimates and predictions to the original scale of y
//' @param trace Logical value, if TRUE tracing information of the estimated parameters are printed
//' @noRd
// [[Rcpp::export]]
Rcpp::List saem_fit_mixed_warped_curves(Rcpp::List curve_list,
                                        Rcpp::List pars_list,
                                        Rcpp::List control_list,
                                        double y_scaling_factor,
                                        bool trace) {

  int seed = Rcpp::as<int>(control_list["seed"]);

  // Special handling of h_break_points as
  // an RcppGSL::Vector object to be propergated to the classes
  RcppGSL::Vector h_break_points = Rcpp::as< RcppGSL::vector<double> >(control_list["h_knots"]);
  RcppGSL::Vector f_break_points = Rcpp::as< RcppGSL::vector<double> >(control_list["f_knots"]);


  // Import parameters
  Rcpp::Rcout << "Import parameters..." << std::endl;
  Mixed_Warped_Model* pars = new Mixed_Warped_Model(pars_list, control_list,
                                                    f_break_points, h_break_points);
  Rcpp::Rcout << "Generate Cholesky centering matrix..." << std::endl;
  pars->generate_chol_centering_mat();

  // Import data
  Rcpp::Rcout << "Import data..." << std::endl;
  std::vector<Mixed_Warped_Curve>* data = new std::vector<Mixed_Warped_Curve>;
  int id = 0;
  for(Rcpp::List::iterator it = curve_list.begin(); it != curve_list.end(); ++it) {
    data->push_back(Mixed_Warped_Curve(*it, pars, id, seed));
    ++id;
  }

  // Initialize basis evaluation matrices
  Rcpp::Rcout << "Initialize basis evaluation matrices..." << std::endl;
  for(std::vector<Mixed_Warped_Curve>::iterator it = data->begin(); it != data->end(); ++it){
    it->initialize_h_basis_mat();
    it->initialize_current_f_basis_mat();
  }


  // Setup multi-threading
#ifdef _OPENMP
  omp_set_num_threads(pars->n_core);
  REprintf("Number of threads=%i\n", omp_get_max_threads());
#endif


  // Setup progress tracking
  int tick = std::max(1, (int) pars->n_iterations / 20);
  Progress p(0, false);
  double progress;
  int saem_idx = 0;
  int curve_idx = 0;

  Rcpp::Rcout << "Entering SAEM loop..." << std::endl;
  // SAEM loop
  for(saem_idx = 0; saem_idx < pars->n_iterations; ++saem_idx){
    // Simulation step
#pragma omp parallel for
    for(curve_idx = 0; curve_idx < data->size(); ++curve_idx){
      data->at(curve_idx).do_simulation_step();
    }
    // Initialize clustering configuration after burn-in
    if(pars->saem_counter == pars->n_burn_saem){
      pars->initialize_clustering_with_user_inputs(data);
    }
    // Centering Step
#pragma omp parallel for
    for(curve_idx = 0; curve_idx < data->size(); ++curve_idx){
      data->at(curve_idx).center_current_a();
    }
    // Stochastic approximation step
#pragma omp parallel for
    for(curve_idx = 0; curve_idx < data->size(); ++curve_idx){
      data->at(curve_idx).update_sufficient_statistics_approximates();
    }
    // MH Calibration
    pars->track_mh_acceptance_and_calibrate_proposal();
    // Maximization step
    pars->gather_sufficient_statistics(data);
    pars->update_estimates();
    pars->track_estimates();
    // Progress report
    if (pars->saem_counter % tick == 0) {
      progress = (double) pars->saem_counter / pars->n_iterations * 100;
      Rprintf("%3.1f%%...", progress);
      if(trace){
        pars->print_estimates(10);
      }
    }
    pars->advance_iteration_counter();
    // Check interruption from R
    if (Progress::check_abort())
      saem_idx = pars->n_iterations; // Bump index to exit the loop
  }
  Rcpp::Rcout << "(Done)" << std::endl;


  // Wrap up as R objects
  Rcpp::List curves(pars->n_curve);
  Rcpp::List est_pars;
  Rcpp::List aux;
  Rcpp::List pars_track;
  Rcpp::List se_info;
  for(int i = 0; i < pars->n_curve; ++i){
    curves[i] = data->at(i).return_list(y_scaling_factor);
  }
  est_pars = pars->return_pars(y_scaling_factor);
  aux = pars->return_aux();
  pars_track = pars->return_pars_tracker(y_scaling_factor);

  // Free memory
  free(data);
  free(pars);

  // Return to R
  return(Rcpp::List::create(
      Rcpp::Named("pars", est_pars),
      Rcpp::Named("curves", curves),
      Rcpp::Named("aux", aux),
      Rcpp::Named("pars_track", pars_track),
      Rcpp::Named("se_info", se_info)));

}




